/*
 *	osgART/GenericTracker
 *	osgART: AR ToolKit for OpenSceneGraph
 *
 *	Copyright (c) 2005-2007 ARToolworks, Inc. All rights reserved.
 *	
 *	Rev		Date		Who		Changes
 *  1.0   	2006-12-08  ---     Version 1.0 release.
 *
 */
// @@OSGART_LICENSE_HEADER_BEGIN@@
// @@OSGART_LICENSE_HEADER_END@@


#ifndef OSGART_GENERICTRACKER
#define OSGART_GENERICTRACKER 1


// std include
#include <map>
#include <iostream>

#include <osg/Geometry>
#include <osg/Projection>

// local include
#include "osgART/Export"
#include "osgART/GenericVideo"
#include "osgART/Marker"
#include "osgART/Field"


namespace osgART {

	/* Forward declaration */
	class VideoLayer;

	/**
	 * \class GenericTracker.
	 * 
	 * Base class for a tracker which in the context of AR is an entity 
	 * that connects video streams, markers and their representation in
	 * the virtual environment.
	 */
	class OSGART_EXPORT GenericTracker : public osg::Referenced, 
		public FieldContainer<GenericTracker>
	{
	public:        
		/**
		 * \brief Constructor.
		 *
		 */
		GenericTracker();

		/**
		 * \brief Initialise a tracker.
		 * \param pattlist_name Pathname to a file containing a list of
		 *		markers to be tracked. Default value is "Data/markers_list.dat".
		 * \param camera_name Pathname to a file containing calibrated
		 *		camera parameters. Default value is "Data/camera_para.dat".
		 */
		virtual bool init(int xsize, int ysize, 
			const std::string& pattlist_name="Data/markers_list.dat",
			const std::string& camera_name="Data/camera_para.dat") = 0;

		/**
		 * \brief Get a unique identifier for this tracker instance.
		 * \return An int representing this particular tracker instance.
		 */
		int getId();

		/** 
		 * \brief Set the image to analyzed.
		 * 
		 * \param video the video object to use
		 */
		void setImageSource(osg::Image* image);
	
    
		/** 
		 * \brief update the tracking.
		 * 
		 * Request that the tracker update the position of tracked
		 * markers, using the most recent image supplied by setImage.
		 */
		virtual void update();
		
		/** 
		 * \brief XXX.
		 * 
		 * XXX.
		 */
		virtual Marker* getMarker(int markerId);
		
		unsigned int getMarkerCount() const;
		
		/** 
		 * \brief get the openGL projection matrix.
		 * 
		 * delivers a usable matrix with openGL code (glLoadMatrixf(proj) with GL_MODELVIEW).
		 * @param proj the openGL projection matrix computed
		 */
		virtual const double* getProjectionMatrix() const;
			
		/**
		 * \brief Return a string that contains the tracker name and version.
		 */	
		std::string		getLabel()const;
		
		virtual void	setEnable(const bool & _enable);
		virtual bool	getEnable()const;

		
	protected:		
	
		/**
		 * Creates an undistorted mesh, according to the 
		 * camera lens distortion parameters known to the tracker.
		 * \param width width of the actual video
		 * \param height height of the actual video
		 * \param maxU texture coordinate maximum in u direction
		 * \param maxV texture coordinate maximum in u direction
		 * \param geometry geometry to be filled with an
		 * undistorted mesh
		 */
		virtual void 
		createUndistortedMesh(int width, int height,
			float maxU, float maxV,
			osg::Geometry &geometry);
		
		/* only videolayer and the container needs to access protected methods */	
		friend class VideoLayer;
		friend class TrackerContainer;
	
		/** 
		 * \brief destructor.
		 */
		virtual ~GenericTracker();
	
		/**
		 * type for a vector of reference counted markers.
		 */
		typedef std::vector< osg::ref_ptr<Marker> > MarkerList;
		
		/**
		 * A list of markers associated with this tracker.
		 */ 
		MarkerList m_markerlist;
		
		double m_projectionMatrix[16];
		std::string		m_name;		//!< Store the name of the tracker.
		std::string		m_version;	//!< Store the version of the tracker.
		bool			m_enable;	//!< Flag to specify if the tracker is enable or not, if we do tracking or not.
		
		osg::ref_ptr<osg::Image> m_imagesource;
		
		unsigned int m_lastModifiedCount;

		
	private:

		int trackerId;
		static int trackerNum;
	}; // class GenericTracker


	/**
	 * The TrackerContainer encapsulates a tracker object.
	 * Its single purpose of existance is to get arround restrictions
	 * within osgIntrospection and RTTI accross DLL boundaries.
	 */
	class OSGART_EXPORT TrackerContainer : public GenericTracker {
	public:

		TrackerContainer(GenericTracker* tracker);

		void update();

		
		virtual bool init(GenericVideo* video, 
			const std::string& pattlist_name="Data/markers_list.dat",
			const std::string& camera_name="Data/camera_para.dat");
		
		
		virtual osg::Projection* createProjection() const;
		

	protected:
	
		virtual bool init(int xsize, int ysize, 
			const std::string& pattlist_name="Data/markers_list.dat",
			const std::string& camera_name="Data/camera_para.dat");
	

		void createUndistortedMesh(int,int,
			float,float,osg::Geometry&);

		virtual ~TrackerContainer();

		osg::ref_ptr<GenericTracker> m_tracker;		
		osg::ref_ptr<GenericVideo> m_video;

	}; // class TrackerContainer
	
}; // namespace osgART

#endif
